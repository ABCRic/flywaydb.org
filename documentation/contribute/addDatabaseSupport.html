---
layout: documentation
menu: addDatabaseSupport
subtitle: Adding Database Support
---
<div id="addDatbaseSupport">
    <h1>Adding Database Support to Flyway</h1>

    <p>Flyway supports migrations for a large number of database platforms in a unified and consistent way. It does
        this by abstracting away the details of each database into a set of classes for each platform, plus factory
        classes that construct the appropriate objects for the database at hand; all communication with the database is
        done through a JDBC connection. The advantage of this approach is that JDBC is a widely adopted standard; with
        little more than a JDBC driver and knowledge of the SQL dialect used by a database it is possible to add Flyway support.
        The Flyway community codebase at <a href="github.com/flyway/flyway">github.com/flyway/flyway</a> is the
        starting point for adding your own database support.
    </p>

    <h2>Why doesn’t Flyway support my favourite databases?</h2>

    <p>We welcome pull requests for database support, but not all requests are automatically accepted. Once support for
        one database enters the mainstream Flyway release we obviously then take on the responsibility of ongoing
        maintenance, which has to be balanced against other priorities for Flyway. We then need to be able to test the
        support effectively, which requires access to an instance without excessive ongoing cost – this generally takes
        the form of a Docker image per version for on-premise databases, or a test account with a cloud provider; these
        are not always available to us. Finally, contributions need to be based on a recent fork with no merge conflicts,
        and also meet the high bar we set for Flyway’s code standard – we can provide advice and code review.
    </p>

    <h2>You will need...</h2>

    <ul>
        <li>A JDBC driver for your database. Please let us know if you would be willing to authorise us to ship the JDBC
        driver with Flyway, as this helps us deliver a more frictionless out-of-the-box experience for end users. If
        you follow step 2 below, this will happen automatically.</li>
        <li>A Java IDE that builds with Java 8 or higher. We use and recommend IntelliJ
        </li>
    </ul>

    <h2>Getting started</h2>

    <p>Fork the Flyway repo. If you’re using IntelliJ, you should be able to open the Flyway top level folder and see a
        number of projects. Copy the file /flyway-commandline/src/main/assembly/flyway.conf to a scratch area; use this
        copy to set up the following properties:
        <ul>
            <li><code>flyway.url</code>	- the JDBC URL of your development database</li>
            <li><code>flyway.user</code> - the user account</li>
            <li><code>flyway.password</code> - the password to the database</li>
            <li><code>flyway.locations</code> - to point to a folder in your scratch area where you can put test migrations.</li>
        </ul>
    </p>

    <p>You can now set up a run configuration in your IDE that will compile Flyway and run using your newly created
        configuration:
        <ul>
            <li>Main class: <code>org.flywaydb.commandline.Main</code></li>
            <li>Program arguments: <code>info -X -configFiles=&lt;scratch area&gt;\flyway.conf</code></li>
            <li>Classpath of module: <code>flyway-commandline</code></li>
        </ul>
    </p>

    <p>Flyway itself should start, and as Flyway doesn’t yet support your database you should see a message like:</p>

    <p><code>org.flywaydb.core.api.FlywayException: Unable to autodetect JDBC driver for url: jdbc:mydatabase://&lt;host&gt;:&lt;port&gt;/&lt;databasename&gt;</code></p>

    <p>You’re now ready to start adding that database support. We’re going to assume your database is called <b>Foo</b>
        – do change the obvious naming conventions to suit your database.
    </p>

    <h2>Let's code!</h2>

    <p>
    Here are all the changes and additions you'll need to make:
        <ol>
            <li>Add an optional dependency to your JDBC driver to the top-level .pom
            </li>
            <li>
                Add a dependency of your JDBC driver to the flyway-commandline .pom if you wish the driver to be
                automatically shipped with the Flyway product.
            </li>
            <li>
                In flyway.conf, document the format of the JDBC connection url for your database. This is not
                necessary to make Flyway work but it will help adoption of your database!
            </li>
            <li>
                Add a case to <code>DriverDataSource.detectDriverForUrl()</code> that returns the fully qualified
                class name of your JDBC driver corresponding to the start of the JDBC connection url.
            </li>
            <li>
                Add an element to the <code>DatabaseType</code> enumeration for your database. You will need to specify
                the JDBC type used to represent NULL in prepared statements for your database, and whether the database
                supports read-only transactions. Then add a case to <code>DatabaseType.fromProductNameAndVersion()</code>
                which should return this DatabaseType when the JDBC connection metadata contains a specific database name.
                Once you have done this, Flyway can select the correct JDBC driver and other classes for this configuration.
            </li>
            <li>
                Create classes <code>FooDatabase</code> (subclassed from Database), <code>FooSchema</code>
                (subclassed from Schema), and <code>FooTable</code> (subclassed from Table), using the canonical
                signatures. These classes make up Flyway’s internal representation of the parts of your database that it works on.
            </li>
            <li>
                Create class <code>FooParser</code> (subclassed from Parser) using the canonical signature. This
                represents a simplified version of a parser for your database’s dialect of SQL. When finished it will
                be able to decompose a migration script into separate statements and report on serious errors, but it
                does not need to fully understand them.
            </li>
            <li>
                In <code>DatabaseFactory</code>, add cases to <code>createDatabase()</code> and <code>createParser()</code>
                that construct these two objects. We will come back to override methods on these classes later.
            </li>
            <li>
                Create class <code>FooConnection</code> subclassed from Connection&lt;FooDatabase&gt; using the
                canonical signature. This represents a JDBC connection to your database. You probably won’t use it in
                isolation but it is an important component of a JdbcTemplate, which provides numerous convenience
                methods for running queries on your database. In the constructor of <code>FooConnection</code>, you can
                use the jdbcTemplate field of Connection to query for any database properties that you need to acquire
                immediately and maintain as part of the state of the connection. You will need to override the following
                methods as a minimum:
                <ul>
                    <li><code>doRestoreOriginalState()</code> – to reset anything that a migration may have changed</li>
                    <li><code>getCurrentSchemaNameOrSearchPath()</code> – to return the current database schema for the
                        connection, if this is a concept in your database, or the default schema name if not.</li>
                    <li><code>doChangeCurrentSchemaOrSearchPath()</code> – to change the current database schema, if
                        this is a concept in your database. If not, use the default which is a no-op.</li>
                    <li><code>getSchema()</code> – to return a constructed <code>FooSchema</code> object.</li>
                </ul>
            </li>
            <li>
                Add overrides for <code>FooDatabase</code> to customise it to fit the SQL conventions of your database:
                <ul>
                    <li><code>doGetConnection()</code> -  to return a new <code>FooConnection</code></li>
                    <li><code>ensureSupported()</code> - to determine which versions of your database will be supported
                        by Flyway. During development, you can leave this as a no-op.</li>
                    <li><code>getRawCreateScript()</code> - to return SQL appropriate for your database to create the
                        schema history table. Refer to an existing database type to see the column types needed. The
                        table name will be provided by the table argument. If the baseline argument is true, this method
                        should also insert a row for the baseline migration.</li>
                    <li><code>getSelectStatement()</code> – to return SQL appropriate for your database to select all
                        rows from the history table with installed_rank greater than a parameter value.</li>
                    <li><code>getInsertStatement()</code> – to return SQL appropriate to insert a row into the history
                        table with nine parameter values (corresponding to the table columns in order).</li>
                    <li><code>supportsDdlTransactions()</code> – to return whether the database can support executing
                        DDL statements inside a transaction or not.</li>
                    <li><code>supportsChangingCurrentSchema()</code> – to return whether the database can support the
                        concept of a current schema attached to a connection, which can be changed via SQL.</li>
                    <li><code>supportsEmptyMigrationDescription()</code> - if your database can't support an empty
                        string in the description column of the history table verbatim (eg. Oracle implicitly converts
                        it to NULL), override this to return false.</li>
                    <li><code>getBooleanTrue()</code> and <code>getBooleanFalse()</code> – to return string
                        representations of the Boolean values as used in your database’s dialect of SQL. Typically
                        these are "true" and "false", but could be, for example, "1" and "0"</li>
                    <li><code>doQuote()</code> - to return an escaped version of an identifier for use in SQL.
                        Typically this is the provided value with a double-quote added either side, but could be,
                        for example, square brackets either side as in SQL Server.</li>
                    <li><code>catalogIsSchema()</code> – to return true if the database uses a catalog to represent a
                        single schema (eg. MySQL, SQLite); false if a catalog is a collection of schemas.</li>
                </ul>
            </li>
            <li>
                Add overrides for <code>FooParser</code> to customise it to fit the SQL dialect your database uses:
                <ul>
                    <li>The constructor should call the superclass constructor with a peek depth. This determines how
                        far in advance the parser looks to determine the nature of various symbols. 2 is a reasonable
                        start, unless you know you have two-character entities like Snowflake’s <code>$$</code> as a
                        javascript delimiter in which case start at 3.</li>
                    <li>Override <code>getDefaultDelimiter()</code> if your database uses something other than a
                        semicolon to delimit separate statements</li>
                    <li>Override <code>getIdentifierQuote()</code> if your database uses something other than a
                        double-quote to escape identifiers (eg. MySQL uses backticks)</li>
                    <li>Override <code>getAlternativeIdentifierQuote()</code> if your database has a second way to
                        escape identifiers in addition to double-quotes.</li>
                    <li>Override <code>getAlternativeStringLiteralQuote()</code> if your database has a second way to
                        mark string literals in addition to single-quotes (eg. MySql allows double-quotes)</li>
                    <li>Override <code>getValidKeywords()</code> if your database has a different set of valid
                        keywords to the standard ones. It's not strictly necessary to include keywords that cannot be
                        found in migration scripts.
                    </li>
                    <li>There are other overrides available for handling more complex SQL; contact us for advice in
                        these cases as it is beyond the scope of this guide.</li>
                </ul>
            </li>
            <li>
                Add overrides for <code>FooSchema</code> to customise it to fit the SQL dialect your database uses:
                <ul>
                    <li><code>doExists()</code> – to query whether the schema described exists in the database</li>
                    <li><code>doEmpty()</code> – to query whether the schema contains any sub-objects eg. tables, views, procedures.</li>
                    <li><code>getObjectCount()</code> – to query the number of objects of a given type that exist in the schema</li>
                    <li><code>doCreate()</code> – to create the schema in the database</li>
                    <li><code>doDrop()</code> – to drop the schema in the database</li>
                    <li><code>doClean()</code> – to drop all the objects that exist in the schema</li>
                    <li><code>doAllTables()</code> – to query for all the tables in the schema and return a populated array of <code>FooTable</code> objects</li>
                    <li><code>getTable()</code> – to return a <code>FooTable</code> object for the given name</li>
                </ul>
            </li>
            <li>
                Add overrides for <code>FooTable</code> to customise it to fit the SQL dialect your database uses:
                <ul>
                    <li><code>doDrop()</code> – to drop the table</li>
                    <li><code>doExists()</code> – to query whether the table described exists in the database</li>
                    <li><code>doLock()</code> – to lock the table with a read/write pessimistic lock until the end of the current transaction.
                        This is used to prevent concurrent reads and writes to the schema history while a migration is underway.
                        If your database doesn’t support table-level locks, do nothing.</li>
                </ul>
            </li>
        </ol>
    </p>

    <h2>Try it!</h2>

    <p>You should at this point be able to run the <code>flyway info</code> build configuration and see an empty version history.
        Congratulations! You have got a basic implementation up and running. You can now start creating migration
        scripts and running <code>flyway migrate</code> on them.</p>

    <p>Basic SQL scripts should run with few problems, but you may find more edge cases, particularly in the Parser.
        The existing classes for a variety of platforms provide plenty of examples of how to deal with them. If you
        find you need to make more invasive changes in the core of Flyway, please do contact us for advice – and
        obviously we will need to test such changes thoroughly against all our test instances before we can accept them.</p>

</div>